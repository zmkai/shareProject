package com.snsoft.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;


import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadBase;
import org.apache.commons.fileupload.ProgressListener;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import utils.DeCompressUtil;
import utils.GetSqlbyId;
import utils.ProrocalUtils;

import com.snsoft.dao.PanDingDao;
import com.snsoft.dao.SubmitDao;
import com.snsoft.domain.FileElement;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;




/**
 * Servlet implementation class MainServlet
 */
@WebServlet("/SubmitServlet")
public class SubmitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public SubmitServlet() {
        super();
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		Map<String, Object> params = new HashMap<String, Object>();
		FileElement fe = new FileElement();
		fe = fileUpload(request, fe);
		String result = "";
		
		if (fe.getAccount() != null) {
			List<Object> list = new ArrayList<Object>();
			list.add(fe.getAccount());
			list.add(fe.getFileName());
			String sqlString = GetSqlbyId.findSqlById("getInfoByfileName");
			boolean bl = new PanDingDao().searchFile(sqlString, list);
			//System.out.println(bl);
			if(bl){
				result=ProrocalUtils.serializeResult(1, "文件名重复", null);
			}else {
				try {
					if ("rar".equals(fe.getFileType())) {
						DeCompressUtil.unrar(fe.getAbsulatePath(), fe.getDestPath());
					} else if ("zip".equals(fe.getFileType())) {
						DeCompressUtil.unzip(fe.getAbsulatePath(), fe.getDestPath());
					} else {

						System.out.println("只支持zip和rar");
						return;
					}
					//拼凑出解压后放置的文件路径
					String destPath = this.getServletContext().getRealPath(File.separator+"dist"+File.separator+fe.getAccount()+File.separator+fe.getFileName());
					//获得文件的目录路径
					String href = destPath.substring(destPath.indexOf("shareProject"));
					String string = href.replaceAll("\\\\", "/");
					string="http://"+request.getServerName()+":"+request.getServerPort()+"/"+string;
					fe.setHref(string);
					

					params.put("id", fe.getId().substring(0, 8));
					params.put("account", fe.getAccount());
					params.put("uploadDate", fe.getUploadDate());
					params.put("fileName", fe.getFileName());
					params.put("href", fe.getHref());
					//将上传文件信息插入数据库
					String sql = GetSqlbyId.findSqlById("insertFileInfo");
					boolean b = new SubmitDao().submit(sql, params);
					if (b) {
						result = ProrocalUtils.serializeResult(0, "上传成功", null);
					} else {
						result = ProrocalUtils.serializeResult(1, "上传失败", null);
					}
					
					File dest = new File(destPath);
					if (!dest.exists()) {
						dest.mkdirs();
					}
					// 拷贝文件夹下的内容到另一个文件夹
					directory(
							(new File(fe.getDestPath()).listFiles()[0])
									.getAbsolutePath(),
							destPath);
					// 删除文件夹
					deleteFile(new File(fe.getDestPath()));
				} catch (Exception e) {
					e.printStackTrace();
				}

			}
			
		} else {
			result = ProrocalUtils.serializeResult(2, "用户未登录", null);
		}
		response.setContentType("json/application");
		response.setCharacterEncoding("utf-8");
		System.out.println(result);
		PrintWriter out = response.getWriter();
		out.write(result);
		out.flush();
		out.close();
		
		
	}
	
	/**
	 * @Method:fileUpload
	 * @Description:文件上传
	 * @param request 请求参数
	 * @return 上传文件的绝对路径
	 */
	public FileElement fileUpload(HttpServletRequest request,FileElement fe) {
		String account = "";
		account = (String) request.getSession().getAttribute("account");
		if (account==null) {
			System.out.println("用户未登录，请先登录");
			return null;
		}
		fe.setAccount(account);
		Date date = new Date();
		fe.setUploadDate(new Timestamp(date.getTime()));
		List types = Arrays.asList("zip","rar");
		// 得到上传文件的保存目录，将上传的文件存放于WebRoot/WEB-INF/upload目录下
		String savePath = this.getServletContext().getRealPath("/WEB-INF/upload");
		// 上传时生成的临时文件保存目录
		String tempPath = this.getServletContext().getRealPath("/temp");
		File tmpFile = new File(tempPath);
		if (!tmpFile.exists()) {
			// 创建临时目录
			tmpFile.mkdir();
		}
		try {
			// 使用Apache文件上传组件处理文件上传步骤：
			// 1、创建一个DiskFileItemFactory工厂
			DiskFileItemFactory factory = new DiskFileItemFactory();
			// 设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。
			factory.setSizeThreshold(1024 * 1024);// 设置缓冲区的大小为100KB，如果不指定，那么缓冲区的大小默认是10KB
			// 设置上传时生成的临时文件的保存目录
			factory.setRepository(tmpFile);
			// 2、创建一个文件上传解析器
			ServletFileUpload upload = new ServletFileUpload(factory);
			upload.setHeaderEncoding("UTF-8");
			// 监听文件上传进度
//			upload.setProgressListener(new ProgressListener() {
//
//				@Override
//				public void update(long pBytesRead, long pContentLength,
//						int arg2) {
//					System.out.println("文件大小为：" + pContentLength + ",当前已处理："
//							+ pBytesRead);
//					/**
//					 * 文件大小为：14608,当前已处理：4096 文件大小为：14608,当前已处理：7367
//					 * 文件大小为：14608,当前已处理：11419 文件大小为：14608,当前已处理：14608
//					 */
//
//				}
//			});

			// 解决上传文件名的中文乱码
			upload.setHeaderEncoding("UTF-8");
			// 3、判断提交上来的数据是否是上传表单的数据
			if (!ServletFileUpload.isMultipartContent(request)) {
				// 按照传统方式获取数据
				return null;
			}

			// 设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是5MB
			upload.setFileSizeMax(5*1024 * 1024);
			// 设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB
			upload.setSizeMax(1024 * 1024 * 10);
			// 4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<FileItem>集合，每一个FileItem对应一个Form表单的输入项
			@SuppressWarnings("unchecked")
			List<FileItem> list = upload.parseRequest(request);
			for (FileItem item : list) {
				// 如果fileitem中封装的是普通输入项的数据
				if (item.isFormField()) {
					String name = item.getFieldName();
					// 解决普通输入项的数据的中文乱码问题
					String value = item.getString("UTF-8");
					// value = new String(value.getBytes("iso8859-1"),"UTF-8");
					System.out.println(name + "=" + value);
					fe.setFileName(value);
				} else {// 如果fileitem中封装的是上传文件
						// 得到上传的文件名称，
					String filename = item.getName();
					//System.out.println(filename);
					if (filename == null || filename.trim().equals("")) {
						continue;
					}
					// 注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：
					// c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt
					// 处理获取到的上传文件的文件名的路径部分，只保留文件名部分
					filename = filename
							.substring(filename.lastIndexOf("\\") + 1);
					// 得到上传文件的扩展名
					String fileExtName = filename.substring(filename
							.lastIndexOf(".") + 1);
					// 如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法
					System.out.println("上传的文件的扩展名是：" + fileExtName);
					if(!types.contains(fileExtName)){
						System.out.println("该文件类型不支持");
						return null;
					}
					fe.setFileType(fileExtName);
					// 获取item中的上传文件的输入流
					InputStream in = item.getInputStream();
					// 得到文件保存的名称
					String saveFilename = makeFileName(filename);
					fe.setId(UUID.randomUUID().toString());
					// 得到文件的保存目录
					String realSavePath = makePath(saveFilename, savePath);
					// 创建一个文件输出流
//					FileOutputStream out = new FileOutputStream(realSavePath
//							+ "\\" + saveFilename);
					FileOutputStream out = new FileOutputStream(realSavePath
							+ File.separator + saveFilename);
					// 创建一个缓冲区
					byte buffer[] = new byte[1024];
					// 判断输入流中的数据是否已经读完的标识
					int len = 0;
					// 循环将输入流读入到缓冲区当中，(len=in.read(buffer))>0就表示in里面还有数据
					while ((len = in.read(buffer)) > 0) {
						// 使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + "\\"
						// + filename)当中
						out.write(buffer, 0, len);
					}
					// 关闭输入流
					in.close();
					// 关闭输出流
					out.close();
					// 删除处理文件上传时生成的临时文件
					item.delete();
					//fe.setAbsulatePath(realSavePath + "\\" + saveFilename);
					fe.setAbsulatePath(realSavePath + File.separatorChar + saveFilename);
					String tempFilePath = this.getServletContext().getRealPath(File.separatorChar+fe.getFileType());
					File tempFile = new File(tempFilePath);
					if(!tempFile.exists()){
						//创建临时目录
						tempFile.mkdirs();
					}
					fe.setDestPath(tempFilePath);
					return fe;
				}
			}
		} catch (FileUploadBase.FileSizeLimitExceededException e) {
			e.printStackTrace();
			System.out.println("单个文件超出最大值！！！");
			return null;
		} catch (FileUploadBase.SizeLimitExceededException e) {
			e.printStackTrace();
			System.out.println("上传文件的总的大小超出限制的最大值！！！");
			return null;
		} catch (Exception e) {
			System.out.println("文件上传失败！");
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * @Method: makeFileName
	 * @Description: 生成上传文件的文件名，文件名以：uuid+"_"+文件的原始名称
	 * @param filename
	 *            文件的原始名称
	 * @return uuid+"_"+文件的原始名称
	 */
	private String makeFileName(String filename) { // 2.jpg
		// 为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名
		return UUID.randomUUID().toString() + "_" + filename;
	}

	/**
	 * 为防止一个目录下面出现太多文件，要使用hash算法打散存储
	 * 
	 * 
	 *
	 * @param filename
	 *            文件名，要根据文件名生成存储目录
	 * @param savePath
	 *            文件存储路径
	 * @return 新的存储目录
	 */
	private String makePath(String filename, String savePath) {
		// 得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址
		int hashcode = filename.hashCode();
		int dir1 = hashcode & 0xf; // 0--15
		int dir2 = (hashcode & 0xf0) >> 4; // 0-15
		// 构造新的保存目录
		String dir = savePath + File.separator + dir1 + File.separator + dir2; // upload\2\3
		// File既可以代表文件也可以代表目录
		File file = new File(dir);
		// 如果目录不存在
		if (!file.exists()) {
			// 创建目录
			file.mkdirs();
		}
		return dir;
	}
	
	 /**
	       * 复制单个文件
	       * @param oldPath 要复制的文件名
	       * @param newPath 目标文件名
	       */
	      public static void copyfile(String oldPath, String newPath) {
	          int hasRead = 0;
	          File oldFile = new File(oldPath);
	          if (oldFile.exists()) {
	              try {
	                  FileInputStream fis = new FileInputStream(oldFile);//读入原文件
	                  FileOutputStream fos = new FileOutputStream(newPath);
	                  byte[] buffer = new byte[1024];
	                  while ((hasRead = fis.read(buffer)) != -1) {//当文件没有读到结尾
	                      fos.write(buffer, 0, hasRead);//写文件
	                  }
	                  fos.flush();
	                  fos.close();
	                  fis.close();
	              } catch (Exception e) {
	                  System.out.println("复制单个文件操作出错！");
	                  e.printStackTrace();
	              }
	          }
	      }
	  
	      /**
	       *
	       * @param oldPath 要复制的文件夹路径
	       * @param newPath 目标文件夹路径
	       */
	      public static void directory(String oldPath, String newPath) {
	         File f1 = new File(oldPath);
	         if(f1.isDirectory()){
	        	 File[] files = f1.listFiles();//listFiles能够获取当前文件夹下的所有文件和文件夹
	        	 for (int i = 0; i < files.length; i++) {
	        		 if (files[i].isDirectory()) {
	        			 File dirNew = new File(newPath + File.separator + files[i].getName());
	        			 dirNew.mkdir();//在目标文件夹中创建文件夹
	        			 //递归
	        			 directory(oldPath + File.separator + files[i].getName(), newPath + File.separator + files[i].getName());
	        		 } else {
	        			 String filePath = newPath + File.separator + files[i].getName();
	        			 copyfile(files[i].getAbsolutePath(), filePath);
	        		 }
	        		 
	        	 }
	        	 
	         }else {
	        	 System.out.println("oldpath="+oldPath+"  "+"newPath="+newPath);
				copyfile(f1.getAbsolutePath(), newPath+File.separator+f1.getName());
			}
	      }
	      
	    //递归删除文件夹  
	      public void deleteFile(File file) {  
	       if (file.exists()) {//判断文件是否存在  
	        if (file.isFile()) {//判断是否是文件  
	         file.delete();//删除文件   
	        } else if (file.isDirectory()) {//否则如果它是一个目录  
	         File[] files = file.listFiles();//声明目录下所有的文件 files[];  
	         for (int i = 0;i < files.length;i ++) {//遍历目录下所有的文件  
	          this.deleteFile(files[i]);//把每个文件用这个方法进行迭代  
	         }  
	         file.delete();//删除文件夹  
	        }  
	       } else {  
	        System.out.println("所删除的文件不存在");  
	       }  
	      }
	
}


